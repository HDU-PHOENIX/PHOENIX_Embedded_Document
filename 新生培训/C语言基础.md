# 嵌入式中的C语言基础
> 本文档介绍嵌入式系统开发中常用的C语言基础知识，包括编译流程、常用数据类型、函数和指针等内容，帮助读者理解如何在嵌入式环境下高效使用C语言进行开发。
## 简单说明
本文档不会介绍C语言本身的语法和用法，而是侧重于嵌入式开发中C语言的特点、编译流程、常用数据类型及其在嵌入式系统中的应用等实用内容，帮助读者理解如何高效地在嵌入式环境下使用C语言进行开发。
## 1. 编译流程 
### 1.1 编译预处理（Preprocessing）
- 作用：处理以 `#` 开头的预处理指令（`#include`、`#define`、条件编译等），展开宏和包含头文件，生成纯 C 代码输入供编译器前端使用。
- 产物：通常是扩展后的源文件，扩展名常为 `.i`（例如 `main.i`）。
### 1.2 编译（Compilation）
- 作用：将预处理后的 C 源代码转换为目标平台相关的汇编代码（.s），并进行语义检查、优化、生成中间表示（IR）等。
- 产物：汇编源文件，扩展名 `.s`（例如 `main.s`）。
### 1.3 汇编（Assembling）
- 作用：将汇编代码（.s）转换为目标文件（机器码封装在目标文件中），扩展名通常为 `.o`。
- 产物：目标文件 `.o`（例如 `main.o`）。
### 1.4 链接（Linking）
- 作用：把多个目标文件和库合并，解析符号引用，分配地址空间，生成可执行文件或固件镜像。嵌入式中特别依赖链接脚本来控制段（section）布局。
- 产物：可执行/可加载文件（如 ELF 文件 `firmware.elf`），以及可选的镜像格式 `.hex`、`.bin`。
### 1.5 后处理：生成镜像 / 烧写用文件
- 作用：从 ELF 等可执行文件提取可烧写的镜像（纯裸二进制或 Intel HEX）。还可以生成符号表、map 文件和反汇编以便调试与分析。
- 产物：烧写用文件（如 `firmware.bin`、`firmware.hex`）

## 2. 变量
### 2.1 int类型
int的字节数会根据编译环境，目标处理器架构不同而变化。16位系统通常为2字节，32位和64位系统通常为4字节。故需要用<stdint.h>头文件中的`uint8_t`,`uint16_t`,`int32_t`,`int64_t`等类型，确保字节不变和可移植性。

### 2.2 float类型
float类型在大多数嵌入式系统中占4字节（32位单精度浮点数），double类型占8字节（64位双精度浮点数）。在嵌入式领域中更常使用float而非double可能也是处于减少内存占用的考虑。然而，一些资源受限的嵌入式系统可能不支持硬件浮点运算，导致浮点运算效率较低。例如不支持硬件加速的stm32f103系列计算一个浮点数需要50~100个CPU周期，而支持硬件加速的stm32f407系列计算一个浮点数只需3~5个CPU周期。因此，在嵌入式系统中使用浮点类型时，应权衡性能和资源消耗，必要时可考虑使用定点数或整数运算来替代浮点运算。

## 3. 函数
函数是C语言的基本模块，用于封装代码逻辑。函数有参数和返回值，支持递归调用。作用域决定变量和函数的可见性，分为局部作用域和全局作用域，请大家遇到重复或过长的处理最好封装成一个函数，方便代码复用和维护，也可以让主程序更清晰易读。

## 4. 指针
指针是存储变量地址的变量，支持指针运算和动态内存管理。    
为什么要用指针可以如下两个程序对比:
```C
// 传值调用
void add(int a){
    a++;
}

int main(){
    int a=0;
    add(a);
    printf("a=%d\n",a);
    return 0;
}
```
```C
// 传址调用
void add(int *a){
    (*a)++;
}
int main(){
    int a=0;
    add(&a);
    printf("a=%d\n",a);
    return 0;
}
```
这里我们会发现a的值只有在第二个程序才会改变，因为第一个程序中add函数接收的是a的值的副本，对副本的修改不会影响原变量。而第二个程序中add函数接收的是a的地址，通过指针可以直接修改原变量的值。或者举一个简单的例子：我要修改一张照片，第一种是相当于我把照片传给朋友，让他帮我修改，但这样我原来的照片并没有变化；第二种是我把手机直接给朋友，让他帮我修改照片，这样我手机里的照片就变了。

## 5. 关键词
### 5.1 volatile
禁止编译器优化，相当于告诉编译器该变量可能在程序外部被修改，确保每次访问都从内存读取最新值，常用于硬件寄存器和多线程编程中。     
示例：
```C
    volatile uint8_t flag;
```
这样的话每一次对`flag`的读写操作，编译器都会直接从内存中进行，而不是使用寄存器中的缓存值，确保程序能够正确响应外部事件或硬件状态的变化。

### 5.2 const
声明只读变量，防止修改其值，常用于定义硬件寄存器地址或不可变数据。      
示例：
```C
    const int16_t ADDRESS = 100;
```
这样声明的`ADDRESS`在程序中不能被修改，任何尝试修改它的操作都会导致编译错误，有助于提高代码的安全性和可维护性。

### 5.3 static
`static` 有三种常见用法：

1. 作用在函数内部变量上——该变量的生命周期贯穿程序运行始终，但作用域仅限于函数内部。变量在函数多次调用间保持其值不变。示例：
```C
void count(void) {
    static int cnt = 0; // 静态局部变量
    cnt++;
}
```
这样每次调用 `count()` 时，`cnt` 的值都会累加，而不是重新初始化。

2. 作用在全局变量上——限制其作用域仅限于当前文件（translation unit），从而防止命名冲突。示例：
```C
static int globalVar = 0; // 仅在当前文件可见
```

3. 作用在函数前——限制函数的可见性仅限于当前文件，防止外部链接调用。示例：
```C
static void helperFunction(void) {
    // 仅在当前文件可见的函数
}
```

### 5.4 #ifndef-#endif
`#ifndef / #define / #endif`（include guard）用于条件编译，常用于防止头文件被多次包含，但它的用途远不止于此。常见原因包括：

1. 防止重复定义（头文件多次包含）。第一次包含时定义宏，后续包含会因宏已定义而跳过头文件内容，避免类型或符号重复定义导致的编译错误。
2. 平台/架构差异：根据不同平台（如 ARM、x86）或编译目标选择不同实现，例如 `#ifdef ARM_BOARD`。
3. 功能开关与特性配置：通过宏打开或关闭可选功能（例如 `#ifdef ENABLE_LOG`）以构建不同功能集的固件。
4. 调试/发布区分：用 `#ifdef DEBUG` 控制断言、日志或测试代码，仅在调试编译时包含。
5. 编译器或库兼容性：针对不同编译器或库版本使用不同实现或修复兼容性问题（例如 `#if defined(__GNUC__)`）。
6. 可选依赖：当外部库存在时包含相关代码（例如 `#ifdef HAVE_LCD`）。
7. 减少预处理与编译开销：避免重复处理大头文件，提高编译速度。

示例：头文件保护（推荐在每个 `.h` 文件中使用）：

```c
#ifndef __HEADER_FILE_NAME_H__
#define __HEADER_FILE_NAME_H__
// 头文件内容
```
此外，对需被 C++ 文件链接的 C 头文件，使用 `extern "C"` 保护：

```c
#ifdef __cplusplus
extern "C" {
#endif

// C 接口声明

#ifdef __cplusplus
}
#endif
```
这样可以确保头文件内容只被包含一次，避免重复定义错误。

## 6. 结构体
结构体（struct）用于将多个相关变量组合成一个复合数据类型，便于管理和传递复杂数据。结构体成员可以是不同类型的数据。     
示例：
```C
typedef struct{
    float out_position;                 // 电机输出轴角度(-PI~PI)
    float out_velocity;                 // 电机输出轴速度(rpm)
    int16_t rotor_position;             // 电机转子角度编码器值
    int16_t rotor_last_position;        // 电机转子上次角度编码器值
    float rotor_velocity;               // 电机转子速度(rpm)
    int16_t total_angle;                // 电机转子累计旋转总角度
    int16_t torque_current;             // 扭计电流(-20A~20A映射到-16384~16384)
    float temperature;                  // 电机温度(°C)
}DjiMotorMessage_s;
DjiMotorMessage_s motor1;
```
> Copyright (c) 2025 PHOENIX
> 作者： 何文轩 <wenx_public@163.com>
> 说明：本文件版权由杭州电子科技大学PHOENIX实验室持有